<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>AnimSequence压缩与解压</title>
    <link href="/2021/07/25/AnimSequence%E5%8E%8B%E7%BC%A9/"/>
    <url>/2021/07/25/AnimSequence%E5%8E%8B%E7%BC%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="AnimSequence-压缩"><a href="#AnimSequence-压缩" class="headerlink" title="AnimSequence 压缩"></a>AnimSequence 压缩</h1><h2 id="动画序列压缩"><a href="#动画序列压缩" class="headerlink" title="动画序列压缩"></a>动画序列压缩</h2><p>在UE4中，动画序列在不进行压缩时会记录各骨骼逐帧的变换数据以及曲线数据，</p><p>可以通过一些配置以对动画序列的帧信息以进行压缩以优化其所占用的内存。</p><p>总的来说，方法主要有以下两种：</p><ol><li>压缩关键帧的数量。</li><li>压缩各关键帧的数据占用量。</li></ol><h3 id="压缩关键帧数量"><a href="#压缩关键帧数量" class="headerlink" title="压缩关键帧数量"></a>压缩关键帧数量</h3><h4 id="压缩格式"><a href="#压缩格式" class="headerlink" title="压缩格式"></a>压缩格式</h4><p>压缩关键帧的格式主要有 <code>VariableKey</code> 和 <code>ConstantKey</code> 两种：</p><ul><li>Variable Key：除了记录下每个关键帧以外，还会使用一个table来记录每一个关键帧在未经压缩的序列帧中的序号。</li><li>Constant Key：只记录关键帧的数据，关键帧与关键帧间时间间隔应该相同。</li></ul><p>UE中使用 <code>AnimEncoding</code> 类来进行压缩与解压，后文会称此类的及其子类为Codec，下面是其重点函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnimEncoding</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 从FMemoryReader中读取动画数据</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ByteSwapIn</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">FUECompressedAnimData&amp; CompressedData,</span></span><br><span class="hljs-params"><span class="hljs-function">FMemoryReader&amp; MemoryReader)</span> <span class="hljs-title">PURE_VIRTUAL</span><span class="hljs-params">(AnimEncoding::ByteSwapIn,)</span></span>;<br><br>    <span class="hljs-comment">// 从MemoryWriter中写入动画数据</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ByteSwapOut</span><span class="hljs-params">( </span></span><br><span class="hljs-params"><span class="hljs-function">        FUECompressedAnimData&amp; CompressedData,</span></span><br><span class="hljs-params"><span class="hljs-function">FMemoryWriter&amp; MemoryWriter)</span> <span class="hljs-title">PURE_VIRTUAL</span><span class="hljs-params">(AnimEncoding::ByteSwapOut, )</span></span>;<br>    <br><span class="hljs-comment">// 得到解压后指定骨骼们的旋转数据</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GetPoseRotations</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">TArrayView&lt;FTransform&gt;&amp; Atoms,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">const</span> BoneTrackArray&amp; DesiredPairs,</span></span><br><span class="hljs-params"><span class="hljs-function">FAnimSequenceDecompressionContext&amp; DecompContext)</span> <span class="hljs-title">PURE_VIRTUAL</span><span class="hljs-params">(AnimEncoding::GetPoseRotations,)</span></span>;<br><br><span class="hljs-comment">// 得到解压后指定骨骼们的位移数据</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GetPoseTranslations</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">TArrayView&lt;FTransform&gt;&amp; Atoms,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">const</span> BoneTrackArray&amp; DesiredPairs,</span></span><br><span class="hljs-params"><span class="hljs-function">FAnimSequenceDecompressionContext&amp; DecompContext)</span> <span class="hljs-title">PURE_VIRTUAL</span><span class="hljs-params">(AnimEncoding::GetPoseTranslations,)</span></span>;<br><br>  <span class="hljs-comment">// 得到解压后指定骨骼们的缩放数据</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GetPoseScales</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">TArrayView&lt;FTransform&gt;&amp; Atoms,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">const</span> BoneTrackArray&amp; DesiredPairs,</span></span><br><span class="hljs-params"><span class="hljs-function">FAnimSequenceDecompressionContext&amp; DecompContext)</span> <span class="hljs-title">PURE_VIRTUAL</span><span class="hljs-params">(AnimEncoding::GetPoseScales,)</span></span>;<br></code></pre></td></tr></table></figure><p>其类图如下：</p><p><img src="/img/content/2021/7/AnimEncoding.png" alt="AnimEncoding"></p><p>其中，AEFVariableKeyLerp类对应了VariableKey压缩格式、AEFConstantKeyLerp类对应了ConstantKey的压缩格式。</p><p>另外，我们可以看到这两个类是泛型类，这与其帧内数据的格式相关，后文会介绍到。</p><p><code>AEFPerTrackCompressionCodec</code> 则是对每一个Track选取不同的压缩格式。</p><h4 id="压缩策略"><a href="#压缩策略" class="headerlink" title="压缩策略"></a>压缩策略</h4><p>在对动画序列进行压缩时，可以选择多种压缩策略，不同的压缩策略会根据自己策略的不同，选取不同的压缩格式以对数据进行压缩。</p><p>例如，RemoveEverySecondKey(隔帧移除)则是每两帧只记录一帧，这样数据量就会减半，这种压缩方式由于帧与帧间的间隔固定，因此很适合使用ConstantKey的压缩格式，这样可以避免关键帧table的开销。</p><p>关于各压缩策略的具体细节，请参考<a href="https://zhuanlan.zhihu.com/p/133253086">UE4 Animation Sequence 的压缩算法</a>，其类图如下：</p><p><img src="/img/content/2021/7/AnimCompress.png" alt="AnimCompress"></p><p>这些压缩策略都继承自 <code>UAnimCompress</code>，其有一个关键函数为 <code>DoReduction</code> ，该函数用于对动画数据进行 <code>剔除</code> 、设置对应的压缩格式、数据格式，并调用 <code>AnimationFormat_SetInterfaceLinks</code> 函数根据之前的设置选取对应的Codec。</p><p>以ConstantKeyLerp为数据格式的位移数据为例，设置其Codec的示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AnimationFormat_SetInterfaceLinks</span><span class="hljs-params">(CompressedDataType&amp; CompressedData)</span></span><br><span class="hljs-function"></span>&#123;<br>CompressedData.TranslationCodec = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-keyword">if</span> (CompressedData.KeyEncodingFormat == AKF_ConstantKeyLerp)<br>&#123;<br>        <span class="hljs-comment">// 实例化各种帧内数据压缩格式的Codec</span><br><span class="hljs-keyword">static</span> AEFConstantKeyLerp&lt;ACF_None&gt;AEFConstantKeyLerp_None;<br><span class="hljs-keyword">static</span> AEFConstantKeyLerp&lt;ACF_Float96NoW&gt;AEFConstantKeyLerp_Float96NoW;<br><span class="hljs-keyword">static</span> AEFConstantKeyLerp&lt;ACF_Fixed48NoW&gt;AEFConstantKeyLerp_Fixed48NoW;<br><span class="hljs-keyword">static</span> AEFConstantKeyLerp&lt;ACF_IntervalFixed32NoW&gt;AEFConstantKeyLerp_IntervalFixed32NoW;<br><span class="hljs-keyword">static</span> AEFConstantKeyLerp&lt;ACF_Fixed32NoW&gt;AEFConstantKeyLerp_Fixed32NoW;<br><span class="hljs-keyword">static</span> AEFConstantKeyLerp&lt;ACF_Float32NoW&gt;AEFConstantKeyLerp_Float32NoW;<br><span class="hljs-keyword">static</span> AEFConstantKeyLerp&lt;ACF_Identity&gt;AEFConstantKeyLerp_Identity;<br><br><span class="hljs-comment">// 根据设置的Format采取实际的Codec</span><br><span class="hljs-built_in"><span class="hljs-keyword">switch</span></span>(CompressedData.TranslationCompressionFormat)<br>&#123;<br><span class="hljs-keyword">case</span> ACF_None:<br>CompressedData.TranslationCodec = &amp;AEFConstantKeyLerp_None;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> ACF_Float96NoW:<br>CompressedData.TranslationCodec = &amp;AEFConstantKeyLerp_Float96NoW;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> ACF_IntervalFixed32NoW:<br>CompressedData.TranslationCodec = &amp;AEFConstantKeyLerp_IntervalFixed32NoW;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> ACF_Identity:<br>CompressedData.TranslationCodec = &amp;AEFConstantKeyLerp_Identity;<br><span class="hljs-keyword">break</span>;<br>&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="压缩帧内数据"><a href="#压缩帧内数据" class="headerlink" title="压缩帧内数据"></a>压缩帧内数据</h3><p>帧内数据有位移、旋转、缩放、曲线数据，根据数据的特性会有不同的压缩方式可以选择。</p><p>概括的说，有以下两种压缩方式：</p><ol><li>不记录可以根据其他数据计算出来的数据。</li><li>降低数据的精度。</li></ol><p>例如，对于旋转而言，由于使用四元数来进行存储，归一化后可以通过XYZ来计算出W，因此使用第一种压缩方式即可省下一个数据，剩下的三个数据可以继续通过第二种方式继续压缩。</p><p>在UE中，有这些数据压缩格式可以选择：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">AnimationCompressionFormat</span></span><br><span class="hljs-class">&#123;</span><br>ACF_None,<br>ACF_Float96NoW,<br>ACF_Fixed48NoW,<br>ACF_IntervalFixed32NoW,<br>ACF_Fixed32NoW,<br>ACF_Float32NoW,<br>ACF_Identity,<br><span class="hljs-function">ACF_MAX <span class="hljs-title">UMETA</span><span class="hljs-params">(Hidden)</span>,</span><br><span class="hljs-function">&#125;</span>;<br></code></pre></td></tr></table></figure><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>关于本文内容尚有许多不足之处，有两篇博客建议阅读：</p><ul><li>压缩算法：<a href="https://zhuanlan.zhihu.com/p/133253086">UE4 Animation Sequence 的压缩算法</a></li><li>压缩流程：<a href="https://zhuanlan.zhihu.com/p/328712220">详解 UE 动画压缩</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>UE4</category>
      
      <category>Animation</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UE4</tag>
      
      <tag>Animtion</tag>
      
      <tag>Compress</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Animation Insight部分原理</title>
    <link href="/2021/07/14/Animation-Insight%E9%83%A8%E5%88%86%E5%8E%9F%E7%90%86/"/>
    <url>/2021/07/14/Animation-Insight%E9%83%A8%E5%88%86%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Animation-Insight-部分原理简介"><a href="#Animation-Insight-部分原理简介" class="headerlink" title="Animation Insight 部分原理简介"></a>Animation Insight 部分原理简介</h1><h2 id="Animation-Insight-是什么"><a href="#Animation-Insight-是什么" class="headerlink" title="Animation Insight 是什么"></a>Animation Insight 是什么</h2><p>Animation Insight是Unreal提供的一款分析动画行为、记录追踪动画信息的插件，事实上Unreal还提供了分析其他系统的其他的Insight工具，此处暂不赘述。</p><p> 若对使用感兴趣，可以参见以下文档或博客：</p><p> <a href="https://docs.unrealengine.com/zh-CN/TestingAndOptimization/PerformanceAndProfiling/UnrealInsights/AnimationInsights/index.html">Animation Insights 概述</a></p><p> <a href="https://zhuanlan.zhihu.com/p/147648443">简述 UnrealInsights</a> <a href="https://docs.unrealengine.com/zh-CN/TestingAndOptimization/PerformanceAndProfiling/UnrealInsights/Overview/index.html">Unreal Insight 概述</a></p><h2 id="Animation-Insight-通信原理"><a href="#Animation-Insight-通信原理" class="headerlink" title="Animation Insight 通信原理"></a>Animation Insight 通信原理</h2><p>笔者比较关心的事情是，因为这套Insight工具是一套插件或者独立程序（目前Animation Insight是一套插件而其余Insight工具作为独立程序），这些动画信息和行为是从引擎那边收集起来并且通知到插件的呢？ </p><p>概括的说，这套系统是一个比较典型的观察者模式，动画信息的收集方是被观察者，而Insight方则为观察者，两者间通过Socket进行解耦、通信。 </p><h3 id="信息处理"><a href="#信息处理" class="headerlink" title="信息处理"></a>信息处理</h3><p> 首先从观察者方来进行研究，来看我们需要的是什么数据，这些数据是怎么来的，以下以AnimMontage为例。</p><p> 观察者的基类是 <code>IAnalyzer</code>， 其有两个关键方法；用于订阅事件的 <code>OnAnalysisBegin()</code> ，以及用于接收这些订阅的 <code>OnEvent()</code> 。 </p><p>下面是 <code>FAnimationAnalyzer</code> 关于Montage的部分源码：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FAnimationAnalyzer::OnAnalysisBegin</span><span class="hljs-params">(<span class="hljs-keyword">const</span> FOnAnalysisContext&amp; Context)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">auto</span>&amp; Builder = Context.InterfaceBuilder;<br><span class="hljs-comment">// ...</span><br>Builder.<span class="hljs-built_in">RouteEvent</span>(RouteId_Montage, <span class="hljs-string">&quot;Animation&quot;</span>, <span class="hljs-string">&quot;Montage&quot;</span>); <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FAnimationAnalyzer::OnEvent</span><span class="hljs-params">(uint16 RouteId, <span class="hljs-keyword">const</span> FOnEventContext&amp; Context)</span></span><br><span class="hljs-function"></span>&#123;<br>Trace::FAnalysisSessionEditScope _(Session);<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; EventData = Context.EventData;<br><span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (RouteId)<br>&#123;<br>    <span class="hljs-keyword">case</span> RouteId_Montage:<br>&#123;<br>uint64 Cycle = EventData.GetValue&lt;uint64&gt;(<span class="hljs-string">&quot;Cycle&quot;</span>);<br>uint64 AnimInstanceId = EventData.GetValue&lt;uint64&gt;(<span class="hljs-string">&quot;AnimInstanceId&quot;</span>);<br>uint64 MontageId = EventData.GetValue&lt;uint64&gt;(<span class="hljs-string">&quot;MontageId&quot;</span>);<br>uint32 CurrentSectionNameId = EventData.GetValue&lt;uint32&gt;(<span class="hljs-string">&quot;CurrentSectionNameId&quot;</span>);<br>uint32 NextSectionNameId = EventData.GetValue&lt;uint32&gt;(<span class="hljs-string">&quot;NextSectionNameId&quot;</span>);<br><span class="hljs-keyword">float</span> Weight = EventData.GetValue&lt;<span class="hljs-keyword">float</span>&gt;(<span class="hljs-string">&quot;Weight&quot;</span>);<br><span class="hljs-keyword">float</span> DesiredWeight = EventData.GetValue&lt;<span class="hljs-keyword">float</span>&gt;(<span class="hljs-string">&quot;DesiredWeight&quot;</span>);<br>uint16 FrameCounter = EventData.GetValue&lt;uint16&gt;(<span class="hljs-string">&quot;FrameCounter&quot;</span>);<br>AnimationProvider.<span class="hljs-built_in">AppendMontage</span>(AnimInstanceId, Context.SessionContext.<span class="hljs-built_in">TimestampFromCycle</span>(Cycle), MontageId, CurrentSectionNameId, NextSectionNameId, Weight, DesiredWeight, FrameCounter);  <span class="hljs-comment">// 将收集到的Montage信息记录下来</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们注意到有一个叫 AnimationProvider 的变量，其是 FAnimationProvider 类的一个实例对象，其作用是用来保存收集到的关于Animation的信息，以用作记录、分析动画信息，关于这个的信息分析本文不作讨论。</p><p>这个类的关键在于，由于每个动画信息的时间、先后都是非常重要的，因此它使用了一个 TimeLine 的设计，Montage采用的是 TPointTimeline 类来记录，这个类会记录每一次Montage播放时的 BeginTime 和 EndTime 等信息。</p><p>从 IAnalyzer 往上查找引用你能找到例如 FAnalysisEngine 类，其用于注册所有Analysis，监听与分发 OnEvent 等作用，再往上追查可以找到关于Socket建立与读取的一些信息，具体的实现细节本文不作讨论。</p><h3 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h3><p>Insight 系统的信息收集使用了 <code>Trace</code> 框架，其是一种结构化的日志记录框架，用于跟踪正在运行的流程中的仪表测量事件。此框架旨在生成高频跟踪事件的流，此类事件自我描述，可以轻松使用和共享。</p><p>其文档描述如下：<a href="https://docs.unrealengine.com/zh-CN/TestingAndOptimization/PerformanceAndProfiling/UnrealInsights/Reference/Trace/index.html">Trace</a> </p><p>以下继续以Montage的信息收集为例。 首先是Montage的信息定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">UE_TRACE_EVENT_BEGIN</span>(Animation, Montage)<span class="hljs-comment">// Animation 是这个这个事件的LoggerName， Montage是这个事件的EventName 使用这两个Name来进行后续的消息派发的路由</span><br><span class="hljs-built_in">UE_TRACE_EVENT_FIELD</span>(uint64, Cycle)<br><span class="hljs-built_in">UE_TRACE_EVENT_FIELD</span>(uint64, AnimInstanceId)<br><span class="hljs-built_in">UE_TRACE_EVENT_FIELD</span>(uint64, MontageId)<br><span class="hljs-built_in">UE_TRACE_EVENT_FIELD</span>(uint32, CurrentSectionNameId)<br><span class="hljs-built_in">UE_TRACE_EVENT_FIELD</span>(uint32, NextSectionNameId)<br><span class="hljs-built_in">UE_TRACE_EVENT_FIELD</span>(<span class="hljs-keyword">float</span>, Weight)<br><span class="hljs-built_in">UE_TRACE_EVENT_FIELD</span>(<span class="hljs-keyword">float</span>, DesiredWeight)<br><span class="hljs-built_in">UE_TRACE_EVENT_FIELD</span>(uint16, FrameCounter)<br><span class="hljs-built_in">UE_TRACE_EVENT_END</span>()<br></code></pre></td></tr></table></figure><p>这里其实是用宏创建了一个类型，然后其每一个字段用一个 <code>TField</code> 类的实例来表示，这里的宏展开后有一个比较有趣的事情，就是使用 <code>decltype</code> 来计算了字段的序号和偏移值，以方便后续的写入缓存：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TRACE_PRIVATE_EVENT_BEGIN_IMPL(LinkageType, LoggerName, EventName, ...) \</span><br><span class="hljs-meta"><span class="hljs-comment">// ...</span></span><br>Trace::TField&lt;<span class="hljs-number">0</span> <span class="hljs-comment">/*Index*/</span>, <span class="hljs-number">0</span> <span class="hljs-comment">/*Offset*/</span>,<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TRACE_PRIVATE_EVENT_FIELD(FieldType, FieldName) \</span><br><span class="hljs-meta">FieldType&gt; const FieldName = Trace::FLiteralName(#FieldName); \</span><br><span class="hljs-meta">Trace::TField&lt; \</span><br><span class="hljs-meta">decltype(FieldName)::Index + 1, \</span><br><span class="hljs-meta">decltype(FieldName)::Offset + decltype(FieldName)::Size,</span><br>  <br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">int</span> InIndex, <span class="hljs-keyword">int</span> InOffset, <span class="hljs-keyword">typename</span> Type&gt; <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TField</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-built_in">TRACE_PRIVATE_FIELD</span>(InIndex, InOffset, Type);<span class="hljs-comment">// 这里声明关于Index、Offset的一些常量</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FActionable</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(uint8* __restrict Ptr)</span> <span class="hljs-keyword">const</span><span class="hljs-comment">// 这里用于后面的数据写入，利用到了字段的Index和Offset</span></span><br><span class="hljs-function"></span>&#123;<br>::<span class="hljs-built_in">memcpy</span>(Ptr + Offset, &amp;Value, Size);<br>&#125;<br>&#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Montage的相关信息在 <code>UAnimInstance::UpdateMontage</code> 方法中进行收集如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TRACE_ANIM_MONTAGE(AnimInstance, MontageInstance) \</span><br><span class="hljs-meta">FAnimTrace::OutputMontage(AnimInstance, MontageInstance);</span><br>   <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UAnimInstance::UpdateMontage</span><span class="hljs-params">(<span class="hljs-keyword">float</span> DeltaSeconds)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//...</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> ANIM_TRACE_ENABLED</span><br><span class="hljs-keyword">for</span> (FAnimMontageInstance* MontageInstance : MontageInstances)<br>&#123;<br><span class="hljs-built_in">TRACE_ANIM_MONTAGE</span>(<span class="hljs-keyword">this</span>, *MontageInstance);<span class="hljs-comment">// 对蒙太奇信息进行收集发送</span><br>&#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>比较有趣的地方是 <code>OutputMontage</code> 方法中发送信息时的技巧，使用对象的生命周期来控制发送信息，如同智能指针的实现一样。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">UE_TRACE_LOG</span>(Animation, Montage, AnimationChannel)<br>&lt;&lt; Montage.<span class="hljs-built_in">Cycle</span>(FPlatformTime::<span class="hljs-built_in">Cycles64</span>())<br>&lt;&lt; Montage.<span class="hljs-built_in">AnimInstanceId</span>(FObjectTrace::<span class="hljs-built_in">GetObjectId</span>(InAnimInstance))<br>&lt;&lt; Montage.<span class="hljs-built_in">MontageId</span>(FObjectTrace::<span class="hljs-built_in">GetObjectId</span>(InMontageInstance.Montage))<br>&lt;&lt; Montage.<span class="hljs-built_in">CurrentSectionNameId</span>(CurrentSectionNameId)<br>&lt;&lt; Montage.<span class="hljs-built_in">NextSectionNameId</span>(NextSectionNameId)<br>&lt;&lt; Montage.<span class="hljs-built_in">Weight</span>(InMontageInstance.<span class="hljs-built_in">GetWeight</span>())<br>&lt;&lt; Montage.<span class="hljs-built_in">DesiredWeight</span>(InMontageInstance.<span class="hljs-built_in">GetDesiredWeight</span>())<br>&lt;&lt; Montage.<span class="hljs-built_in">FrameCounter</span>(FObjectTrace::<span class="hljs-built_in">GetObjectWorldTickCounter</span>(InAnimInstance));<br></code></pre></td></tr></table></figure><p>展开宏以后，会发现其实在宏中创建了一个 <code>FLogScope</code> 类型的实例对象，利用它的构造函数来构建数据包的包头，而利用其 &lt;&lt; 操作符以将蒙太奇的一些数据并写入缓存，再利用其析构函数将这些数据进行提交。 其重点代码如下： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">inline</span> FEventDef::FLogScope::<span class="hljs-built_in">FLogScope</span>(uint16 EventUid, uint16 Size, uint32 EventFlags)<br>&#123;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">bool</span> bMaybeHasAux = EventFlags &amp; FEventDef::Flag_MaybeHasAux;<br>Instance = (EventFlags &amp; FEventDef::Flag_NoSync)<br>? <span class="hljs-built_in">Writer_BeginLogNoSync</span>(EventUid, Size, bMaybeHasAux)<br>: <span class="hljs-built_in">Writer_BeginLog</span>(EventUid, Size, bMaybeHasAux);<br>&#125;<br><span class="hljs-keyword">inline</span> FEventDef::FLogScope::~<span class="hljs-built_in">FLogScope</span>()<br>&#123;<br><span class="hljs-built_in">Writer_EndLog</span>(Instance);<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> ActionType&gt;<br><span class="hljs-keyword">inline</span> <span class="hljs-keyword">const</span> FEventDef::FLogScope&amp; <span class="hljs-keyword">operator</span> &lt;&lt; (<span class="hljs-keyword">const</span> FEventDef::FLogScope&amp; Lhs, <span class="hljs-keyword">const</span> ActionType&amp; Rhs)<br>&#123;<br>Rhs.<span class="hljs-built_in">Write</span>(Lhs.Instance.Ptr);<br><span class="hljs-keyword">return</span> Lhs;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>UE4</category>
      
      <category>Insight</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Note</tag>
      
      <tag>UE4</tag>
      
      <tag>Unreal Insight</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用工具与插件推荐</title>
    <link href="/2021/05/11/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E4%B8%8E%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/"/>
    <url>/2021/05/11/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E4%B8%8E%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/</url>
    
    <content type="html"><![CDATA[<h1 id="常用工具推荐"><a href="#常用工具推荐" class="headerlink" title="常用工具推荐"></a>常用工具推荐</h1><blockquote><p>用作备忘，不定期更新</p></blockquote><h2 id="Windows-工具篇"><a href="#Windows-工具篇" class="headerlink" title="Windows 工具篇"></a>Windows 工具篇</h2><h3 id="uTools-工具集合"><a href="#uTools-工具集合" class="headerlink" title="uTools 工具集合"></a>uTools 工具集合</h3><p><a href="https://u.tools/"><code>uTools</code></a> 是一个工具集，有很多的开发者提供了很多很方便的功能，在特定的情境下可以很方便的启用一些特定的功能，例如在文件夹页面中快速打开 Everything 工具来对此文件夹下进行文件搜索，或者当你截取一张图片时，让它悬浮在最上层。<br>推荐的部分功能：</p><ul><li>本地搜索 ： 使用Everything来进行本地搜索。</li><li>Translate ： 翻译选中文本。</li><li>字数统计 ： 对选中的字数进行一些统计分析。</li><li>悬浮 ： 当截取图片等操作时，可以让图片悬浮在最上层。</li></ul><h3 id="aText"><a href="#aText" class="headerlink" title="aText"></a>aText</h3><p><a href="https://www.trankynam.com/atext/"><code>aText</code></a> 是一个文本模板、文本宏等功能的工具，可以方便快速的输入一些常用的文本，例如如果有一些非常无聊但是需要经常用到的代码，你可以直接输入一个你自己规定好的短语以及对应的代码，以后输入这个短语时，工具会帮你展开成对应的哪些代码，十分便捷。</p><h3 id="Typera"><a href="#Typera" class="headerlink" title="Typera"></a>Typera</h3><p><a href="https://www.typora.io/"><code>Typora</code></a> 是一个非常简洁实用的Markdown编辑器。</p><h2 id="Visual-Studio-工具篇"><a href="#Visual-Studio-工具篇" class="headerlink" title="Visual Studio 工具篇"></a>Visual Studio 工具篇</h2><h3 id="Visual-Assist-X"><a href="#Visual-Assist-X" class="headerlink" title="Visual Assist X"></a>Visual Assist X</h3><p>Visual Assist X是一个很实用的C++的工具，用于进行UE开发非常方便。  </p><p><a href="https://zhuanlan.zhihu.com/p/56769102">配置推荐</a>  </p><p>另外，在每次打开工程时，VA会对工程进行分析，如果是大型工程的话，这个过程会非常缓慢，因此推荐关闭在打开时分析全工程选项：</p><p><img src="/images/pasted-1.png" alt="关闭在打开时分析全工程选项"></p><h2 id="Chrome工具篇"><a href="#Chrome工具篇" class="headerlink" title="Chrome工具篇"></a>Chrome工具篇</h2><h3 id="Youtube-双字幕"><a href="#Youtube-双字幕" class="headerlink" title="Youtube 双字幕"></a>Youtube 双字幕</h3><p>机翻字幕，双字幕便于对照。</p><h3 id="AdBlock-—-最佳广告拦截工具"><a href="#AdBlock-—-最佳广告拦截工具" class="headerlink" title="AdBlock — 最佳广告拦截工具"></a>AdBlock — 最佳广告拦截工具</h3><p>拦截掉浏览器的很多广告。</p><h3 id="Momentum"><a href="#Momentum" class="headerlink" title="Momentum"></a>Momentum</h3><p>新建页每日更新一张图，并且有TODO功能。</p><h3 id="为什么你们就是不能加个空格呢？"><a href="#为什么你们就是不能加个空格呢？" class="headerlink" title="为什么你们就是不能加个空格呢？"></a>为什么你们就是不能加个空格呢？</h3><p>优化页面显示效果。</p>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tool</tag>
      
      <tag>Note</tag>
      
      <tag>Chrome</tag>
      
      <tag>Windows</tag>
      
      <tag>Visual Studio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Behaviac 编辑器部分流程</title>
    <link href="/2021/05/10/Behaviac%20%E7%BC%96%E8%BE%91%E5%99%A8%E9%83%A8%E5%88%86%E6%B5%81%E7%A8%8B/"/>
    <url>/2021/05/10/Behaviac%20%E7%BC%96%E8%BE%91%E5%99%A8%E9%83%A8%E5%88%86%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Behaviac-编辑器部分流程"><a href="#Behaviac-编辑器部分流程" class="headerlink" title="Behaviac 编辑器部分流程"></a>Behaviac 编辑器部分流程</h1><h2 id="插件制作流程"><a href="#插件制作流程" class="headerlink" title="插件制作流程"></a>插件制作流程</h2><h3 id="插件基础"><a href="#插件基础" class="headerlink" title="插件基础"></a>插件基础</h3><p><a href="https://www.behaviac.com/tutorial9_extendnodes/">拓展节点类型</a></p><h2 id="新建节点流程"><a href="#新建节点流程" class="headerlink" title="新建节点流程"></a>新建节点流程</h2><h3 id="节点类型的加载"><a href="#节点类型的加载" class="headerlink" title="节点类型的加载"></a>节点类型的加载</h3><p>插件加载进去后，在 <code>Plugin</code> 的构造方法内会调用一些方法来注册节点信息：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Plugin.RegisterTypeHandlers(_DesignerBaseDll);<br>Plugin.RegisterAgentTypes(_DesignerBaseDll);<br>Plugin.InitNodeGroups();<br>Plugin.RegisterNodeDesc(_DesignerBaseDll);<br></code></pre></td></tr></table></figure><p>其中，<code>RegisterNodeDesc</code> 会根据节点的层次关系，生成一些描述节点。</p><p>这些描述节点会合并到 <code>Plugin</code> 类的 <code>NodeGroup</code> 类型的静态集合 <code>_nodeGroups</code> 中去， <code>NodeGroup</code> 是一种用于描述节点的、树状的结构类型。</p><p>在 <code>BehaviocTreeList</code> 类中有一个 <code>LoadPlugins</code> 方法会在 Workspace 发生变化的时候来进行调用，其会调用到一个 <code>ToggleShowSelectedNodes</code> 方法用于将刚刚得到的哪些描述信息来注册到 <code>TreeView</code> 来让屏幕上展示Node的结构，如下所示：</p><p><img src="/img/content/2021/5/Node%E7%BB%93%E6%9E%84.png"></p><p>此外，在这个方法内也会调用 <code>Register</code> 方法创建Node类型所对应的 <code>NodeTag</code> 以用于后续生成时所需的一些信息。</p><h3 id="节点拖拽创建的重要事件"><a href="#节点拖拽创建的重要事件" class="headerlink" title="节点拖拽创建的重要事件"></a>节点拖拽创建的重要事件</h3><p>以向行为树节点加入一个 <code>True</code> 节点为例：</p><p><img src="/img/content/2021/5/True%E8%8A%82%E7%82%B9.png"></p><p>在 <code>BehaviorTreeView</code> 类中有一个事件 <code>BehaviorTreeView_DragDrop</code> 会在你拖拽节点过来释放后触发，在经过多番校验后，会调用 <code>InsertNewNode</code> 方法来向目标节点进行插入新节点，根据对应的节点信息调用 <code> newnode = Node.Create(nodetag.NodeType)</code> 方法以创建新节点， <code>InsertNewNode</code>  方法签名如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 把从节点浏览器中拖拽过来的节点连接到一个现有的节点上</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;nvd&quot;&gt;</span> 被连接到的节点，即目标节点 <span class="hljs-doctag">&lt;/param&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;mode&quot;&gt;</span> 连接的方式 <span class="hljs-doctag">&lt;/param&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;nodetag&quot;&gt;</span> 你想要创建的节点的tag，里面有类型信息 <span class="hljs-doctag">&lt;/param&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InsertNewNode</span>(<span class="hljs-params">NodeViewData nvd, NodeAttachMode mode, NodeTag nodetag, PointF mousePos</span>)</span><br></code></pre></td></tr></table></figure><p>在这个方法中，会有很多的类型判断以采取不同的方案，在本例中，则会调用到 <code>node.AddChild(_dragTargetConnector, newnode)</code> 以将新创建的节点联系到目标节点上，在这个函数调用中，里面会有 <code>connector.AcceptsChild(node)</code> 方法的调用，以判断该目标节点能否接收这个新节点。</p><h3 id="节点属性的绘制"><a href="#节点属性的绘制" class="headerlink" title="节点属性的绘制"></a>节点属性的绘制</h3><p>节点属性绘制以 <code>Action</code> 节点的 <code>Method</code> 属性为例，其绘制的效果如下：</p><p><img src="/img/content/2021/5/%E8%8A%82%E7%82%B9%E5%B1%9E%E6%80%A7%E7%BB%98%E5%88%B6.png"></p><p>在 <code>PropertiesDock</code> 类中，有一个 <code>SelectedObject</code> 属性用于保存当前选中的节点，在其 Set 函数中，会根据节点的类型来反射创建其相关属性，<code>Method</code> 即是其中之一。</p><p>在选中节点不为空的情况下，会调用方法 <code>UpdateProperties</code> 以绘制各属性。</p><p>在此方法中，会根据属性的类型，获取其对应的 Editor 的type，对于此例来说，调试的情况下可以看到类型是 <code>DesignerMethodComboEnumEditor</code> 。此类即Method属性的编辑器展示时的类型，其会缓存当前的Agent类型然后根据Agent的方法来改变枚举的值。</p>]]></content>
    
    
    <categories>
      
      <category>Winform Editor</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI</tag>
      
      <tag>Editor</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
